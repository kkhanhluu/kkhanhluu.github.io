{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/transactional-outbox/","result":{"data":{"site":{"siteMetadata":{"title":"Kim Khanh Luu"}},"markdownRemark":{"id":"d1020dde-2ba8-5139-8d46-2ab890bf2a5d","excerpt":"Transactional outbox pattern Context and problem In context of a microservices architecture, a service typically needs to update data and database and then sendâ€¦","html":"<h1>Transactional outbox pattern</h1>\n<h1>Context and problem</h1>\n<p>In context of a microservices architecture, a service typically needs to update data and database and then send message to message broker. For example, in saga pattern, which was discussed in <a href=\"https://kkhanhluu.github.io/saga/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the previous post</a>, after updating database, a service sends message to the next participant in saga or to saga orchestrator. Because this action spans across two components: <strong>database</strong> and <strong>message broker</strong>, itâ€™s possible that service cannot publish message to broker after updating its own database due to various reasons: network error, message broker is unavailable,â€¦</p>\n<p>The simplest approach for this problem is to send message in the middle of a local ACID database transaction. However, thereâ€™s no guarantee that the transaction will commit if sending messages always fail. Similarly, if a service sends a message after committing the transaction thereâ€™s no guarantee that it wonâ€™t crash before sending the message. As a result, we need a mechanism to update database and send message atomically in order to avoid bug and inconsistency.</p>\n<h1>Transactional outbox pattern</h1>\n<p>The transactional outbox pattern is a technique that writes the event to an outbox within the same database transaction that triggers the event. The outbox acts as a buffer that holds the events until they can be reliably published to the message broker or event bus. The event is then published asynchronously by a separate background process <strong>(message relay)</strong> that reads from the outbox and publishes the events to the message broker or event bus.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/526ff165e67ff72a04679672cc608c8d/0c156/outbox_pattern.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.24050632911392%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA1ElEQVQoz42RAQqDMAxFe/9bjsFAoVOrVq3VP14hQ6YDCyVtmrzkp06S9n3HaJom9X1f7LZtOr7dXY4ES5rnWXVdaxxH5Zy/QHu/A3fHC5BhGLQsyynQwMd9VcTRFRJTSooxKoRQZANl4//X2VUR13WdmqYp3ZlUwMAIwK7r+gVQgLuN5CSZDtu2LVADk+S9LzNlBChg4acoTeDLWy6fN6VZz75SHd9yBCETGBAA+EhCOn6sKTAgKiiIgm4IeoSXqujlrAObJYH4SLTz8cdNso3hV/IHiz90XANs2UEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"outbox pattern.png\"\n        title=\"outbox pattern.png\"\n        src=\"/static/526ff165e67ff72a04679672cc608c8d/f058b/outbox_pattern.png\"\n        srcset=\"/static/526ff165e67ff72a04679672cc608c8d/c26ae/outbox_pattern.png 158w,\n/static/526ff165e67ff72a04679672cc608c8d/6bdcf/outbox_pattern.png 315w,\n/static/526ff165e67ff72a04679672cc608c8d/f058b/outbox_pattern.png 630w,\n/static/526ff165e67ff72a04679672cc608c8d/40601/outbox_pattern.png 945w,\n/static/526ff165e67ff72a04679672cc608c8d/78612/outbox_pattern.png 1260w,\n/static/526ff165e67ff72a04679672cc608c8d/0c156/outbox_pattern.png 1473w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>The participants in this pattern are:</p>\n<ul>\n<li><strong>Sender</strong>: the service that sends the message.</li>\n<li><strong>Database</strong>: the senderâ€™s database that stores business data and message outbox.</li>\n<li><strong>Message outbox</strong>: a table or any storage that stores the messages to be sent.</li>\n<li><strong>Message relay:</strong> a component that is responsible for sending messages stored in <strong>outbox</strong> to message broker.</li>\n</ul>\n<h2>Message outbox</h2>\n<p>The implementation for the message outbox can be very different. It can be a separate table, thatâ€™s just responsible for storing messages to be sent. In some other cases, the outbox is just a property of each database record.</p>\n<h2>Message relay</h2>\n<p>There are two patterns for implementing message relay:</p>\n<ul>\n<li><strong>Polling publisher</strong></li>\n<li><strong>Transaction log tailing</strong></li>\n</ul>\n<h3>Polling publisher</h3>\n<p>Itâ€™s a component that keeps polling the outbox in database and publishes messages. Polling works quite well at low scale, however frequently polling the database does not fit well in a large scale. You can checkout an example of a polling publisher in my <a href=\"https://kkhanhluu.github.io/e-shop/explore/code/transactional-outbox-pattern\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">e-shop project</a>, which implement message relay as a cronjob that run at a scheduled pace.</p>\n<h3>Transaction log tailing</h3>\n<p>Every update made to database is represented as an entry in databaseâ€™s transaction log. In this pattern, we implement the message replay as a transaction log miner, which reads the transaction log entities, converts those entities to corresponding message inserted to database and then sends those message to message broker. The mechanism for tailing the transaction log depends on the database: WAL for Postgres, binlog for MySQL,â€¦</p>\n<h1>Summary</h1>\n<p>The transactional outbox pattern is a pattern where events are written to an outbox within the same database transaction as the business transaction. This decouples the transactional semantics from event publishing, ensuring reliable event delivery even in the face of failures. <strong>Message relay</strong> is a important component in transactional outbox pattern and can be implemented by using <strong>polling publisher</strong> or <strong>transaction log tailing.</strong></p>","frontmatter":{"title":"ðŸ“¤ Transactional outbox pattern","date":"April 23, 2023","description":"Introduction outbox pattern","time":"10"}},"previous":{"fields":{"slug":"/saga/"},"frontmatter":{"title":"ðŸš¦ Saga pattern"}},"next":null},"pageContext":{"id":"d1020dde-2ba8-5139-8d46-2ab890bf2a5d","previousPostId":"ffb645e3-45eb-56b7-b717-50b5df6014a8","nextPostId":null}},"staticQueryHashes":["1642819152"]}